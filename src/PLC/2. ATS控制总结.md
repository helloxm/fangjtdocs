---
title: 断路器控制
index: 1
---


# 断路器控制
- 现在开-关处于什么位置
    - 开的位置， 关的位置
    ```st
        OPEN_POS_CUR := open_pos AND NOT close_pos;
        CLOSE_POS_CUR := close_pos AND NOT open_pos;
    ```
- 开关有没有位置错误
    - 加tFaultTime延时判断
    ```st
        bIN := (open_pos AND close_pos) or (NOT open_pos AND NOT close_pos);
        pt  := tFaultTime;
        tonFaultPos : Ton;
        tonFaultPos(IN := bIN, PT := pt, Q => FAULT_POS);
    ```
- 开关位置正确
    ```st
        POS_OK  := OPEN_POS_CUR XOR CLOSE_POS_CUR;
        POS_OK  : = POS_OK AND NOT FAULT_POS;
    ```
- 可以开？
    - 处于关触电
    - 来了开指令
    - 关触电和开指令，在做一个Ton，防抖动
    - 将结果做一个锁存，输出是否可以开
    - 锁存器的reset信号来自 atsresetlockout or 当前处于开触点
    ```st
        bIN := CLOSE_POS_CUR AND open_cmd;
        pt  : = tOpenCheck;
        tonOpenCheck    : Ton;
        tonOpenCheck(IN := bIN, PT := pt, Q => bWouldBeOpen);
        sr  : SR;
        sr.set := bWouldBeOpen;
        sr.reset := ats_reset_lockout or OPEN_POS_CUR;
        bOpen := sr.Q;
    ```
- 可以关？ 同理 开关开？
    ```st
        bIN := OPEN_POS_CUR AND close_cmd;
        pt  : = tCloseCheck;
        tonCloseCheck    : Ton;
        tonCloseCheck(IN := bIN, PT := pt, Q => bWouldBeClose);
        sr  : SR;
        sr.set := bWouldBeClose;
        sr.reset := ats_reset_lockout or CLOSE_POS_CUR;
        bClose := sr.Q;
    ```
- 执行开？
    - 可以开
    - 同意尝试开retryOpen
    - 以上2个条件同时成立，然后输出执行开脉冲tOpenDnoe时钟
    ```st
        bOpenDone := bOpen AND bRetryOpen;
        tp  : TP;
        tp(IN := bOpenDone, PV := tOpenDnoe, Q => bOpenExecute)
    ```
- 开超时？
    - 处于关位置，执行了开操作了，但是没有执行开
    - 为了防抖，做一个ton,
    - 做一个输出锁存, reset信号： atsresetlockout or 当前处于开触点
    ```st
        bOpenTimeout := bOpen AND NOT bOpenExecute;
        tonOpenTimeout : Ton;
        tonOpenTimeout(IN := bOpenTimeout, PT := tOpenTimeout, Q => bTonOpenTimeout);
        sr : SR;
        sr.set := bTonOpenTimeout;
        sr.reset := ats_reset_lockout or OPEN_POS_CUR;
        TRV_OPEN_TIMEOUT := sr.Q;
    ```
- 开超时后，做一个是否可以再尝试
    - 已超时
    - 没超过尝试次数bMoreThanOpenCnt
    - 要执行开动作bOpen
    - 做一个ton延时，防抖
    ```st
        bRetryOpenIN := TRV_OPEN_TIMEOUT AND bopen AND NOT bMoreThanOpenCnt;
        tonRetryOpen : Ton;
        tonRetryOpen(IN:=bRetryOpenIN, PT:=tRetry, Q => bRetryOpen);
    ```
- 开超过次数？
    - 允许bRetryOpen
    - 使用CTU计数
    ```st
        ctuOpenCnt : CTU;
        ctuOpenCnt(IN := bRetryOpen, PV:=iMaxOpenCnt, RESET:= ats_reset_lockout OR OPEN_POS_CUR, Q => bMoreThanOpenCnt);
    ```